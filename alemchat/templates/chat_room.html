{%load static %}
<!doctype html>
<html>
    <head>
    <meta charset="utf-8">
    <title>Chat with {{ other.username }}</title>
    <meta name="viewport" content="width=device-widht, initial-scale=1">
    <style>
        body{
            margin: 0;font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        }
        .topbar{position: sticky; top: 0; padding: 12px 16px; border-bottom: 1px solid #eee; background: #fff;}
        .wrap{display: flex; flex-direction: column; height: 100svh;}
        .messages {flex: 1;overflow-y: auto; padding: 12px;background:#fafafa;}
        .row{display: flex; margin: 6px 0;}
        .mine {justify-content: flex-end;}
        .bubble{ max-width: 70%; padding: 10px 12px; border-radius: 16px; background: #fff; box-shadow: 0 1px 1px rgba(0, 0, 0, .06);}
        .mine .bubble{background: #dff1ff;}
        .meta{font-size: 12px; color: #666; margin: 2px 8px;}
        .composer { display: flex; gap: 8px; padding: 10px;border-top: 1px solid #eee;}
        .composer input {flex: 1; padding: 10px 12px; border-radius: 20px;border:1px solid #ddd; outline: none;}
        .composer button { padding: 8px 14px; border-radius:16px;border: 0;background:#1a73e8; color: #fff;}
        .typing { font-size: 12px; color: #888; padding:0 16px 8px;}
    </style>
</head>
<body>
    <div class="wrap">
        <div class="topbar">
            <strong>@{{other.username}}</strong>
        </div>

        <div class="messages" id="messages">
            {%for m in initial_messages %}
            <div class="row {% if m.sender_id == request.user.id %}mine{%endif%}" data-id="{{ m.id }}">
                <div class="bubble">{{m.text| linebreaksbr }}</div>
            </div>
            {%endfor%}
        </div>

        <div class="typing" id="typing" style="display: none;">{{other.username}} is typing...</div>

        <form id="composer" class="composer">
            {%csrf_token%}
            <input id="text" name="text" autocomplete="off" placeholder="Message..."/>
            <button type="submit">Send</button>
        </form>
    </div>
    <script>

    const chatId = {{chat.id}};
    const msgsE1 = document.getElementById('messages');
    const typingE1 = document.getElementById('typing');
    const inputE1 = document.getElementById('text');
    const formE1 = document.getElementById('composer');

    // CSRF helper
    function getCookie(name){
        const v = document.cookie.split(';').map(c=>c.trim()).find(c=>c.startsWith(name+'='));
        return v ? decodeURIComponent(v.split('=')[1]) : '';
    }
    const csrftoken = getCookie('csrftoken');

    let lastId = (function(){
        const last = msgsE1.querySelector('.row:last-child');
        return last ? parseInt(last.getAttribute('data-id')) : 0;
    })();

    function appendMessage(m){
        const row = document.createElement('div');
        row.className = 'row' + (m.mine ? 'mine' : '');
        row.setAttribute('data-id', m.id);
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.textContent = m.text;
        row.appendChild(bubble);
        msgsE1.appendChild(row);
        msgsE1.scrollTop = msgsE1.scrollHeight;
    }

    // Poll for new messages + typing
    async function poll() {
        try{
            const url = `{% url 'api_fetch_messages' chat.id %}?after_id=${lastId}`;
            const res = await fetch(url, {credentials:"same-origin"});
            if (!res.ok) return;
            const data = await res.json();
            if (Array.isArray(data.messages)) {
                data.messages.forEach(m => {
                    appendMessage(m);
                    lastId = Math.max(lastId, m.id);
                });
            }
            typingE1.style.display = data.typing ? 'block' : 'none'; 
        } catch (e) { /* silent */ }
    }
    setInterval(poll, 1500);
    window.addEventListener('focus', poll);
    document.addEventListener('visibilitychange', ()=> { if (!document.hidden) poll(); });

    //send message 
    formE1.addEventListener('submit', async (e) =>{
        e.preventDefault();
        const text = inputE1.value.trim();
        if (!text) return;
        inputE1.value = '';
        const formData = new FormData();
        formData.append('text', text);
        const res = await fetch(`{% url 'api_send_message' chat.id %}`, {
            method:'POST',
            credentials:'same-origin',
            headers: {'X-CSRFToken': csrftoken},
            body: formData
        });
        if (res.ok) {
            const m = await res.json();
            appendMessage({ ...m, mine: true });
            lastId = Math.max(lastId, m.id);
        }
    });

    //Typing pings (throttled)
    let lastPing = 0;
    inputE1.addEventListener('input', ()=>{
        const now = Date.now();
        if (now - lastPing < 1000) return;
        lastPing = now;
        fetch(`{% url 'api_typing_ping' chat.id %}`, {
            method: 'POST',
            credentials: 'same-origin',
            headers: {'X-CSRFToken': csrftoken}
        });
    });

    //Auto-Scroll on load
    msgsE1.scrollTop = msgsE1.scrollHeight;
    </script>
</body>
</html>